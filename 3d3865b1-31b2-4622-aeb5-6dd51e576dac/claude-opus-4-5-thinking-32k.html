<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saharsh Gobi-LOW IQ Adventures</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a1a;
            overflow: hidden;
            color: white;
        }
        #gameCanvas { display: block; }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: none;
            justify-content: space-between;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .hud-item {
            background: rgba(0,0,0,0.6);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #444;
        }
        
        #healthBar {
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            transition: width 0.3s;
        }
        
        #bossHealthContainer {
            display: none;
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            text-align: center;
        }
        
        #bossHealthBar {
            width: 100%;
            height: 30px;
            background: #333;
            border-radius: 15px;
            overflow: hidden;
            border: 3px solid #ff0000;
        }
        
        #bossHealthFill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff4444);
            transition: width 0.3s;
        }
        
        #menu, #gameOver, #victory {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
        }
        
        #menu {
            background: linear-gradient(135deg, rgba(20,20,40,0.95), rgba(40,20,60,0.95));
            padding: 40px 60px;
            border-radius: 20px;
            border: 3px solid #6644aa;
            box-shadow: 0 0 50px rgba(100,68,170,0.5);
        }
        
        #menu h1 {
            font-size: 42px;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d, #6bcb77, #4d96ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbow 3s infinite;
        }
        
        @keyframes rainbow {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(180deg); }
        }
        
        #menu h2 {
            font-size: 24px;
            color: #aaa;
            margin-bottom: 30px;
        }
        
        .character-preview {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            margin: 20px auto;
            border: 4px solid #ffd93d;
            object-fit: cover;
        }
        
        .btn {
            background: linear-gradient(135deg, #6644aa, #8866cc);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 30px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(102,68,170,0.8);
        }
        
        #gameOver, #victory {
            display: none;
            background: rgba(0,0,0,0.9);
            padding: 40px 60px;
            border-radius: 20px;
        }
        
        #gameOver { border: 3px solid #ff4444; }
        #victory { border: 3px solid #44ff44; }
        
        #worldTransition {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-size: 32px;
        }
        
        .controls-info {
            font-size: 14px;
            color: #888;
            margin-top: 20px;
            line-height: 1.8;
        }
        
        #crosshair {
            position: absolute;
            width: 30px;
            height: 30px;
            display: none;
            pointer-events: none;
        }
        
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: #00ffff;
            box-shadow: 0 0 10px #00ffff;
        }
        
        #crosshair::before {
            width: 3px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #crosshair::after {
            height: 3px;
            width: 100%;
            top: 50%;
            transform: translateY(-50%);
        }
        
        #crosshair .dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ff0000;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .damage-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,0,0,0.3);
            animation: flash 0.2s ease-out;
            pointer-events: none;
        }
        
        @keyframes flash {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 16px;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="hud">
            <div class="hud-item">
                <div id="scoreDisplay">Score: 0</div>
            </div>
            <div class="hud-item">
                <div id="worldDisplay">World 1: Grade Escape</div>
            </div>
            <div class="hud-item">
                <div id="objectiveDisplay">Collect 1000 coins!</div>
            </div>
            <div class="hud-item">
                <div>Health</div>
                <div id="healthBar"><div id="healthFill"></div></div>
            </div>
        </div>
        
        <div id="bossHealthContainer">
            <div style="font-size: 24px; color: #ff4444; margin-bottom: 10px;">JOB APPLICATION BOSS</div>
            <div id="bossHealthBar"><div id="bossHealthFill"></div></div>
        </div>
        
        <div id="menu">
            <h1>ðŸŽ® Saharsh Gobi</h1>
            <h2>LOW IQ Adventures</h2>
            <img src="https://asset-cdn.schoology.com/system/files/imagecache/profile_big/pictures/picture-c0b09cdead19788fb0f8be0d53b5c572_68c34cd700b90.jpg" 
                 class="character-preview" alt="Saharsh" onerror="this.style.display='none'">
            <br>
            <button class="btn" onclick="startGame()">START ADVENTURE</button>
            <div class="controls-info">
                <strong>CONTROLS:</strong><br>
                WASD - Move | SPACE - Jump<br>
                World 3: Left Click - Shoot Centrix Gun
            </div>
        </div>
        
        <div id="gameOver">
            <h1 style="color: #ff4444; font-size: 48px;">ðŸ’€ GAME OVER ðŸ’€</h1>
            <p style="margin: 20px 0; font-size: 20px;" id="deathReason">The grades caught you!</p>
            <button class="btn" onclick="startGame()">TRY AGAIN</button>
        </div>
        
        <div id="victory">
            <h1 style="color: #44ff44; font-size: 36px;">ðŸŽ‰ VICTORY! ðŸŽ‰</h1>
            <h2 style="color: #ffd93d; margin: 20px 0;">CENTRIX ULTIMATE HACKED!</h2>
            <p style="font-size: 18px; color: #aaa;">It was all a prank! ðŸ˜‚</p>
            <img src="https://asset-cdn.schoology.com/system/files/imagecache/profile_big/pictures/picture-c0b09cdead19788fb0f8be0d53b5c572_68c34cd700b90.jpg" 
                 style="width: 100px; height: 100px; border-radius: 50%; margin: 20px;" onerror="this.style.display='none'">
            <br>
            <button class="btn" onclick="startGame()">PLAY AGAIN</button>
        </div>
        
        <div id="worldTransition">
            <div id="transitionText">Teleporting to World 2...</div>
            <div style="font-size: 18px; margin-top: 20px; color: #888;">Get ready!</div>
        </div>
        
        <div id="crosshair"></div>
        <div id="instructions"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script>
        // Game State
        let scene, camera, renderer, player;
        let gameState = 'menu';
        let currentWorld = 1;
        let score = 0;
        let health = 100;
        let redBoxesCollected = 0;
        let bossHealth = 100;
        let homeworksRemaining = 0;
        let lastBossHealthThreshold = 100;
        
        // Controls
        const keys = { w: false, a: false, s: false, d: false, space: false };
        let velocity = new THREE.Vector3();
        let canJump = true;
        let isGrounded = true;
        
        // World objects
        let coins = [];
        let obstacles = [];
        let grades = [];
        let boxes = [];
        let bullets = [];
        let enemies = [];
        let boss = null;
        let platforms = [];
        
        // Timers
        let spawnTimer = 0;
        let gradeDistance = 50;
        
        // Mouse aiming
        let mouse, raycaster;
        let aimTarget = new THREE.Vector3();
        
        function onMouseMove(event) {
            if (!mouse) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Move crosshair to follow mouse in World 3
            if (currentWorld === 3) {
                const crosshair = document.getElementById('crosshair');
                crosshair.style.left = (event.clientX - 15) + 'px';
                crosshair.style.top = (event.clientY - 15) + 'px';
            }
        }
        
        // Initialize Three.js
        function init() {
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Event Listeners
            window.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = true;
                if (e.code === 'Space') { keys.space = true; e.preventDefault(); }
            });
            
            window.addEventListener('keyup', (e) => {
                if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = false;
                if (e.code === 'Space') keys.space = false;
            });
            
            window.addEventListener('click', shoot);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Mouse position for aiming
            mouse = new THREE.Vector2();
            raycaster = new THREE.Raycaster();
            
            animate();
        }
        
        function startGame() {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('victory').style.display = 'none';
            document.getElementById('hud').style.display = 'flex';
            
            gameState = 'playing';
            currentWorld = 1;
            score = 0;
            health = 100;
            redBoxesCollected = 0;
            bossHealth = 100;
            lastBossHealthThreshold = 100;
            
            setupWorld1();
            updateHUD();
        }
        
        function clearWorld() {
            coins.forEach(c => scene.remove(c));
            obstacles.forEach(o => scene.remove(o));
            grades.forEach(g => scene.remove(g));
            boxes.forEach(b => scene.remove(b));
            bullets.forEach(b => scene.remove(b));
            enemies.forEach(e => scene.remove(e));
            platforms.forEach(p => scene.remove(p));
            if (boss) scene.remove(boss);
            if (player) scene.remove(player);
            
            coins = [];
            obstacles = [];
            grades = [];
            boxes = [];
            bullets = [];
            enemies = [];
            platforms = [];
            boss = null;
            
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            
            // Re-add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);
        }
        
        // WORLD 1: Temple Run Style
        function setupWorld1() {
            clearWorld();
            scene.background = new THREE.Color(0x1a0a2e);
            scene.fog = new THREE.Fog(0x1a0a2e, 10, 100);
            
            // Ground
            const groundGeo = new THREE.PlaneGeometry(20, 1000);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x333366 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.z = -450;
            ground.receiveShadow = true;
            scene.add(ground);
            platforms.push(ground);
            
            // Player (Saharsh)
            const playerGeo = new THREE.BoxGeometry(1, 2, 1);
            const playerMat = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
            player = new THREE.Mesh(playerGeo, playerMat);
            player.position.set(0, 1, 0);
            player.castShadow = true;
            scene.add(player);
            
            // Add face texture attempt
            const faceGeo = new THREE.PlaneGeometry(0.8, 0.8);
            const faceMat = new THREE.MeshBasicMaterial({ color: 0xffddaa });
            const face = new THREE.Mesh(faceGeo, faceMat);
            face.position.z = 0.51;
            face.position.y = 0.5;
            player.add(face);
            
            // Grades (chasing enemy)
            const gradeGeo = new THREE.BoxGeometry(15, 8, 3);
            const gradeMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x440000 });
            const grade = new THREE.Mesh(gradeGeo, gradeMat);
            grade.position.set(0, 4, 50);
            scene.add(grade);
            grades.push(grade);
            
            // Add "F" text representation
            const fGeo = new THREE.BoxGeometry(2, 4, 0.5);
            const fMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const fMesh = new THREE.Mesh(fGeo, fMat);
            fMesh.position.z = 1.6;
            grade.add(fMesh);
            
            gradeDistance = 50;
            
            // Spawn initial coins
            for (let i = 0; i < 50; i++) {
                spawnCoin(-i * 15 - 20);
            }
            
            // Spawn obstacles
            for (let i = 0; i < 30; i++) {
                spawnObstacle(-i * 25 - 30);
            }
            
            camera.position.set(0, 8, 12);
            camera.lookAt(0, 2, -10);
            
            document.getElementById('worldDisplay').textContent = 'World 1: Grade Escape';
            document.getElementById('objectiveDisplay').textContent = 'Collect 1000 coins!';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('bossHealthContainer').style.display = 'none';
        }
        
        function spawnCoin(z) {
            const coinGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 16);
            const coinMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0x886600 });
            const coin = new THREE.Mesh(coinGeo, coinMat);
            coin.rotation.x = Math.PI / 2;
            coin.position.set((Math.random() - 0.5) * 8, 1 + Math.random() * 2, z);
            scene.add(coin);
            coins.push(coin);
        }
        
        function spawnObstacle(z) {
            const obsGeo = new THREE.BoxGeometry(2 + Math.random() * 2, 2, 2);
            const obsMat = new THREE.MeshStandardMaterial({ color: 0x444488 });
            const obs = new THREE.Mesh(obsGeo, obsMat);
            obs.position.set((Math.random() - 0.5) * 6, 1, z);
            scene.add(obs);
            obstacles.push(obs);
        }
        
        // WORLD 2: Educational Boxes
        function setupWorld2() {
            clearWorld();
            scene.background = new THREE.Color(0x0a1a0a);
            scene.fog = new THREE.Fog(0x0a1a0a, 20, 80);
            
            // Ground
            const groundGeo = new THREE.PlaneGeometry(60, 60);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x225522 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            platforms.push(ground);
            
            // Walls
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x114411 });
            for (let i = 0; i < 4; i++) {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(60, 10, 2), wallMat);
                wall.position.y = 5;
                if (i === 0) wall.position.z = -30;
                else if (i === 1) wall.position.z = 30;
                else if (i === 2) { wall.rotation.y = Math.PI / 2; wall.position.x = -30; }
                else { wall.rotation.y = Math.PI / 2; wall.position.x = 30; }
                scene.add(wall);
            }
            
            // Player
            const playerGeo = new THREE.BoxGeometry(1, 2, 1);
            const playerMat = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
            player = new THREE.Mesh(playerGeo, playerMat);
            player.position.set(0, 1, 0);
            player.castShadow = true;
            scene.add(player);
            
            // TP Machine (appears after collecting 10 red boxes)
            const tpGeo = new THREE.CylinderGeometry(2, 2, 4, 8);
            const tpMat = new THREE.MeshStandardMaterial({ color: 0x8800ff, emissive: 0x440088, transparent: true, opacity: 0.7 });
            const tpMachine = new THREE.Mesh(tpGeo, tpMat);
            tpMachine.position.set(0, 2, -20);
            tpMachine.visible = false;
            tpMachine.name = 'tpMachine';
            scene.add(tpMachine);
            
            redBoxesCollected = 0;
            spawnTimer = 0;
            
            camera.position.set(0, 20, 25);
            camera.lookAt(0, 0, 0);
            
            document.getElementById('worldDisplay').textContent = 'World 2: Education World';
            document.getElementById('objectiveDisplay').textContent = 'Collect 10 RED boxes! (0/10)';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('bossHealthContainer').style.display = 'none';
        }
        
        function spawnBox() {
            // Weighted spawn: 50% red, 25% blue, 25% green to ensure enough red boxes
            const rand = Math.random();
            let type;
            if (rand < 0.5) type = 'red';
            else if (rand < 0.75) type = 'blue';
            else type = 'green';
            
            let color, points;
            if (type === 'red') { color = 0xff0000; points = 30; }
            else if (type === 'blue') { color = 0x0000ff; points = -40; }
            else { color = 0x00ff00; points = -20; }
            
            const boxGeo = new THREE.BoxGeometry(2, 2, 2);
            const boxMat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
            const box = new THREE.Mesh(boxGeo, boxMat);
            // Keep boxes within visible bounds
            box.position.set((Math.random() - 0.5) * 40, 1, (Math.random() - 0.5) * 40);
            box.userData = { type, points };
            scene.add(box);
            boxes.push(box);
        }
        
        // WORLD 3: Boss Fight
        function setupWorld3() {
            clearWorld();
            scene.background = new THREE.Color(0x1a0a0a);
            scene.fog = new THREE.Fog(0x1a0a0a, 30, 100);
            
            // Arena ground
            const groundGeo = new THREE.CircleGeometry(40, 32);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x442222 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            platforms.push(ground);
            
            // Player with gun
            const playerGeo = new THREE.BoxGeometry(1, 2, 1);
            const playerMat = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
            player = new THREE.Mesh(playerGeo, playerMat);
            player.position.set(0, 1, 20);
            player.castShadow = true;
            scene.add(player);
            
            // Gun
            const gunGeo = new THREE.BoxGeometry(0.2, 0.2, 1);
            const gunMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
            const gun = new THREE.Mesh(gunGeo, gunMat);
            gun.position.set(0.5, 0, -0.5);
            player.add(gun);
            
            // Boss - Job Application
            const bossGeo = new THREE.BoxGeometry(8, 10, 2);
            const bossMat = new THREE.MeshStandardMaterial({ color: 0x880000, emissive: 0x330000 });
            boss = new THREE.Mesh(bossGeo, bossMat);
            boss.position.set(0, 5, -25);
            boss.userData = { health: 100 };
            scene.add(boss);
            
            // Boss label
            const labelGeo = new THREE.PlaneGeometry(6, 2);
            const labelMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const label = new THREE.Mesh(labelGeo, labelMat);
            label.position.y = 6;
            label.position.z = 1.1;
            boss.add(label);
            
            bossHealth = 100;
            lastBossHealthThreshold = 100;
            homeworksRemaining = 0;
            
            camera.position.set(0, 5, 30);
            
            document.getElementById('worldDisplay').textContent = 'World 3: Boss Fight!';
            document.getElementById('objectiveDisplay').textContent = 'Defeat the Job Application Boss!';
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('bossHealthContainer').style.display = 'block';
            updateBossHealthBar();
        }
        
        function spawnHomework() {
            const hwGeo = new THREE.BoxGeometry(2, 3, 0.5);
            const hwMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x333333 });
            const hw = new THREE.Mesh(hwGeo, hwMat);
            const angle = Math.random() * Math.PI * 2;
            const dist = 15 + Math.random() * 10;
            hw.position.set(Math.cos(angle) * dist, 1.5, Math.sin(angle) * dist);
            hw.userData = { health: 30, type: 'homework' };
            scene.add(hw);
            enemies.push(hw);
            homeworksRemaining++;
        }
        
        function shoot() {
            if (gameState !== 'playing' || currentWorld !== 3) return;
            
            const bulletGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const bulletMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            bullet.position.copy(player.position);
            bullet.position.y += 0.5;
            
            // Use raycaster to get mouse aim direction
            raycaster.setFromCamera(mouse, camera);
            
            // Create a ground plane to intersect with
            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const targetPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(groundPlane, targetPoint);
            
            // If no intersection with ground, shoot toward where mouse points in 3D space
            if (!targetPoint.x && !targetPoint.z) {
                targetPoint.set(
                    player.position.x + raycaster.ray.direction.x * 50,
                    1,
                    player.position.z + raycaster.ray.direction.z * 50
                );
            }
            
            // Calculate direction from player to target
            const direction = new THREE.Vector3();
            direction.subVectors(targetPoint, player.position).normalize();
            direction.y = 0; // Keep bullet horizontal
            
            bullet.userData = { velocity: direction.multiplyScalar(1.5) };
            
            scene.add(bullet);
            bullets.push(bullet);
        }
        
        function updateWorld1(delta) {
            // Player movement
            const moveSpeed = 0.3;
            if (keys.a) player.position.x -= moveSpeed;
            if (keys.d) player.position.x += moveSpeed;
            player.position.x = Math.max(-8, Math.min(8, player.position.x));
            
            // Auto-run forward
            player.position.z -= 0.4;
            
            // Jump
            if (keys.space && isGrounded) {
                velocity.y = 0.4;
                isGrounded = false;
            }
            
            // Gravity
            velocity.y -= 0.02;
            player.position.y += velocity.y;
            
            if (player.position.y <= 1) {
                player.position.y = 1;
                velocity.y = 0;
                isGrounded = true;
            }
            
            // Move grades closer
            grades.forEach(g => {
                g.position.z = player.position.z + gradeDistance;
                gradeDistance -= 0.01; // Grades get closer over time
            });
            
            // Check grade collision
            if (gradeDistance < 5) {
                gameOver('The grades caught you!');
                return;
            }
            
            // Coin collection
            coins.forEach((coin, i) => {
                coin.rotation.y += 0.1;
                if (player.position.distanceTo(coin.position) < 2) {
                    scene.remove(coin);
                    coins.splice(i, 1);
                    score += 25; // 25 points per coin
                    
                    // Spawn new coin ahead
                    spawnCoin(player.position.z - 300 - Math.random() * 50);
                }
                
                // Remove coins behind
                if (coin.position.z > player.position.z + 20) {
                    scene.remove(coin);
                    coins.splice(i, 1);
                    spawnCoin(player.position.z - 300 - Math.random() * 50);
                }
            });
            
            // Obstacle collision
            obstacles.forEach((obs, i) => {
                if (player.position.distanceTo(obs.position) < 2 && player.position.y < 2.5) {
                    gradeDistance -= 5; // Hitting obstacle slows you down
                    health -= 15; // Obstacles now drain health
                    scene.remove(obs);
                    obstacles.splice(i, 1);
                    flashDamage();
                }
                
                if (obs.position.z > player.position.z + 20) {
                    scene.remove(obs);
                    obstacles.splice(i, 1);
                    spawnObstacle(player.position.z - 400 - Math.random() * 100);
                }
            });
            
            // Check health in World 1 too
            if (health <= 0) {
                gameOver('You ran out of health!');
                return;
            }
            
            // Camera follow
            camera.position.z = player.position.z + 12;
            camera.position.x = player.position.x * 0.3;
            camera.lookAt(player.position.x * 0.5, 2, player.position.z - 10);
            
            // Check win condition
            if (score >= 1000) {
                transitionToWorld(2);
            }
        }
        
        function updateWorld2(delta) {
            // Player movement
            const moveSpeed = 0.2;
            if (keys.w) player.position.z -= moveSpeed;
            if (keys.s) player.position.z += moveSpeed;
            if (keys.a) player.position.x -= moveSpeed;
            if (keys.d) player.position.x += moveSpeed;
            
            // Boundary
            player.position.x = Math.max(-28, Math.min(28, player.position.x));
            player.position.z = Math.max(-28, Math.min(28, player.position.z));
            
            // Jump
            if (keys.space && isGrounded) {
                velocity.y = 0.3;
                isGrounded = false;
            }
            
            velocity.y -= 0.02;
            player.position.y += velocity.y;
            
            if (player.position.y <= 1) {
                player.position.y = 1;
                velocity.y = 0;
                isGrounded = true;
            }
            
            // Spawn boxes periodically
            spawnTimer += delta;
            if (spawnTimer > 1 && boxes.length < 15) {
                spawnBox();
                spawnTimer = 0;
            }
            
            // Box collection/collision
            boxes.forEach((box, i) => {
                box.rotation.y += 0.02;
                
                if (player.position.distanceTo(box.position) < 2) {
                    if (box.userData.type === 'red') {
                        score += 30;
                        redBoxesCollected++;
                        document.getElementById('objectiveDisplay').textContent = `Collect 10 RED boxes! (${redBoxesCollected}/10)`;
                    } else {
                        health += box.userData.points;
                        flashDamage();
                    }
                    scene.remove(box);
                    boxes.splice(i, 1);
                }
            });
            
            // Check health
            if (health <= 0) {
                gameOver('You ran out of health!');
                return;
            }
            
            // Show TP machine when ready
            const tpMachine = scene.getObjectByName('tpMachine');
            if (redBoxesCollected >= 10 && tpMachine) {
                tpMachine.visible = true;
                tpMachine.rotation.y += 0.05;
                
                if (player.position.distanceTo(tpMachine.position) < 3) {
                    transitionToWorld(3);
                }
                
                document.getElementById('objectiveDisplay').textContent = 'Go to the TP Machine!';
            }
            
            // Camera
            camera.position.set(player.position.x, 20, player.position.z + 15);
            camera.lookAt(player.position);
        }
        
        function updateWorld3(delta) {
            // Player movement
            const moveSpeed = 0.2;
            if (keys.w) player.position.z -= moveSpeed;
            if (keys.s) player.position.z += moveSpeed;
            if (keys.a) player.position.x -= moveSpeed;
            if (keys.d) player.position.x += moveSpeed;
            
            // Boundary
            const dist = Math.sqrt(player.position.x ** 2 + player.position.z ** 2);
            if (dist > 35) {
                player.position.x *= 35 / dist;
                player.position.z *= 35 / dist;
            }
            
            // Look at boss
            player.lookAt(0, player.position.y, -25);
            
            // Jump
            if (keys.space && isGrounded) {
                velocity.y = 0.3;
                isGrounded = false;
            }
            
            velocity.y -= 0.02;
            player.position.y += velocity.y;
            
            if (player.position.y <= 1) {
                player.position.y = 1;
                velocity.y = 0;
                isGrounded = true;
            }
            
            // Update bullets
            bullets.forEach((bullet, i) => {
                bullet.position.add(bullet.userData.velocity);
                
                // Check boss hit
                if (boss && bullet.position.distanceTo(boss.position) < 6) {
                    bossHealth -= 5;
                    updateBossHealthBar();
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    
                    // Spawn homework at thresholds
                    if (bossHealth <= lastBossHealthThreshold - 25) {
                        lastBossHealthThreshold -= 25;
                        for (let j = 0; j < 5; j++) {
                            spawnHomework();
                        }
                    }
                    
                    if (bossHealth <= 0) {
                        victory();
                        return;
                    }
                }
                
                // Check homework hit
                enemies.forEach((enemy, j) => {
                    if (bullet.position.distanceTo(enemy.position) < 2) {
                        enemy.userData.health -= 15;
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                        
                        if (enemy.userData.health <= 0) {
                            scene.remove(enemy);
                            enemies.splice(j, 1);
                            homeworksRemaining--;
                            score += 20;
                        }
                    }
                });
                
                // Remove out of range bullets
                if (bullet.position.distanceTo(player.position) > 100) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            });
            
            // Enemies chase player
            enemies.forEach(enemy => {
                const dir = new THREE.Vector3();
                dir.subVectors(player.position, enemy.position).normalize();
                enemy.position.add(dir.multiplyScalar(0.08));
                enemy.lookAt(player.position);
                
                // Damage player
                if (enemy.position.distanceTo(player.position) < 2) {
                    health -= 0.5;
                    flashDamage();
                }
            });
            
            // Boss attack (move toward player slowly)
            if (boss) {
                boss.rotation.y += 0.01;
                
                // Boss shoots projectiles occasionally
                if (Math.random() < 0.01) {
                    const projGeo = new THREE.SphereGeometry(0.5, 8, 8);
                    const projMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                    const proj = new THREE.Mesh(projGeo, projMat);
                    proj.position.copy(boss.position);
                    const dir = new THREE.Vector3();
                    dir.subVectors(player.position, boss.position).normalize();
                    proj.userData = { velocity: dir.multiplyScalar(0.3), isBossProjectile: true };
                    scene.add(proj);
                    bullets.push(proj);
                }
            }
            
            // Check boss projectile hits
            bullets.forEach((bullet, i) => {
                if (bullet.userData.isBossProjectile) {
                    if (bullet.position.distanceTo(player.position) < 1.5) {
                        health -= 10;
                        flashDamage();
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                    }
                }
            });
            
            // Check health
            if (health <= 0) {
                gameOver('You were defeated by the Job Application!');
                return;
            }
            
            // Camera
            camera.position.set(player.position.x, 8, player.position.z + 15);
            camera.lookAt(0, 5, -25);
        }
        
        function transitionToWorld(worldNum) {
            gameState = 'transition';
            document.getElementById('worldTransition').style.display = 'flex';
            
            const messages = {
                2: 'Teleporting to Educational World...',
                3: 'Entering the Boss Arena...'
            };
            document.getElementById('transitionText').textContent = messages[worldNum];
            
            setTimeout(() => {
                currentWorld = worldNum;
                document.getElementById('worldTransition').style.display = 'none';
                gameState = 'playing';
                
                if (worldNum === 2) setupWorld2();
                else if (worldNum === 3) setupWorld3();
            }, 2000);
        }
        
        function flashDamage() {
            const flash = document.createElement('div');
            flash.className = 'damage-flash';
            document.getElementById('ui').appendChild(flash);
            setTimeout(() => flash.remove(), 200);
        }
        
        function updateHUD() {
            document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
            document.getElementById('healthFill').style.width = `${Math.max(0, health)}%`;
        }
        
        function updateBossHealthBar() {
            document.getElementById('bossHealthFill').style.width = `${Math.max(0, bossHealth)}%`;
        }
        
        function gameOver(reason) {
            gameState = 'gameover';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('bossHealthContainer').style.display = 'none';
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('deathReason').textContent = reason;
        }
        
        function victory() {
            gameState = 'victory';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('bossHealthContainer').style.display = 'none';
            document.getElementById('victory').style.display = 'block';
        }
        
        let lastTime = 0;
        function animate(time = 0) {
            requestAnimationFrame(animate);
            
            const delta = (time - lastTime) / 1000;
            lastTime = time;
            
            if (gameState === 'playing') {
                if (currentWorld === 1) updateWorld1(delta);
                else if (currentWorld === 2) updateWorld2(delta);
                else if (currentWorld === 3) updateWorld3(delta);
                
                updateHUD();
            }
            
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>
