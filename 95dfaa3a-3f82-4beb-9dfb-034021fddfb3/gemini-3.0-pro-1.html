<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saharsh's Class Failing Game - SecureCentrix Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Roboto', sans-serif;
            user-select: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        /* HUD */
        .hud-panel {
            position: absolute;
            padding: 20px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            display: none; /* Hidden initially */
        }

        .top-left {
            top: 0;
            left: 0;
        }

        .top-right {
            top: 0;
            right: 0;
            text-align: right;
        }

        .gpa-bar-container {
            width: 300px;
            height: 30px;
            background: #444;
            border: 4px solid #000;
            margin-top: 10px;
            position: relative;
        }

        .gpa-bar-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff4b4b, #ffcd3c, #3cff55);
            transition: width 0.2s;
        }

        .gpa-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            color: #fff;
        }

        .score-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            color: #00d2ff; /* SecureCentrix Blue */
        }

        /* Menus */
        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            z-index: 20;
        }

        h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 48px;
            color: #00d2ff;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 4px 4px 0 #ff0055;
            line-height: 1.5;
        }

        p {
            font-size: 18px;
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
            margin-bottom: 30px;
        }

        .btn {
            font-family: 'Press Start 2P', cursive;
            padding: 20px 40px;
            font-size: 20px;
            background: #00d2ff;
            color: #000;
            border: 4px solid #fff;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            text-transform: uppercase;
        }

        .btn:hover {
            transform: scale(1.1);
            background: #fff;
            color: #00d2ff;
        }

        .hidden {
            display: none !important;
        }

        /* Dynamic Tags */
        .floating-text {
            position: absolute;
            font-family: 'Press Start 2P', cursive;
            color: white;
            pointer-events: none;
            font-size: 14px;
            text-shadow: 2px 2px 0 #000;
            animation: floatUp 1s forwards;
        }

        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
    </style>
</head>
<body>

    <!-- 3D Container -->
    <div id="game-container"></div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div id="hud" class="hud-panel top-left">
            <div class="gpa-text">CURRENT GPA: <span id="gpa-val">4.0</span></div>
            <div class="gpa-bar-container">
                <div id="gpa-bar" class="gpa-bar-fill"></div>
            </div>
        </div>
        <div id="hud-right" class="hud-panel top-right">
            <div class="score-text">SECURECENTRIX XP: <span id="score-val">0</span></div>
            <div style="font-size: 12px; margin-top:5px; color: #aaa;">TARGET: 2500 XP</div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen">
        <h1>SAHARSH'S<br>CLASS FAILING GAME</h1>
        <p>Saharsh is supposed to be studying, but he wants to play on <strong>SecureCentrix</strong> instead!</p>
        <p><strong>Controls:</strong> WASD or Arrows to move.<br>
        <strong>Goal:</strong> Collect <span style="color:#00d2ff">Blue Laptops</span> to gain XP.<br>
        <strong>Avoid:</strong> <span style="color:#ff4b4b">Red Assignments & F's</span>. If they hit you, your GPA drops.</p>
        <button class="btn" onclick="startGame()">START SKIPPING CLASS</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen hidden">
        <h1 style="color: #ff4b4b; text-shadow: 4px 4px 0 #000;">EXPELLED!</h1>
        <p>Your GPA hit 0.0. You failed all your classes and got banned from SecureCentrix.</p>
        <div class="score-text" style="margin-bottom: 20px;">FINAL XP: <span id="final-score">0</span></div>
        <button class="btn" onclick="resetGame()">RETAKE YEAR</button>
    </div>

    <!-- Win Screen -->
    <div id="win-screen" class="screen hidden">
        <h1 style="color: #3cff55; text-shadow: 4px 4px 0 #000;">SUMMER BREAK!</h1>
        <p>You successfully ignored all your responsibilities and became a SecureCentrix Legend!</p>
        <button class="btn" onclick="resetGame()">PLAY AGAIN</button>
    </div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Game Configuration ---
        const CONFIG = {
            playerSpeed: 0.8,
            arenaSize: 80,
            enemySpeed: 0.3,
            enemySpawnRate: 60, // Frames
            collectibleSpawnRate: 100,
            damage: 0.5, // GPA damage
            gpaMax: 4.0,
            scoreWin: 2500,
            saharshImage: 'https://asset-cdn.schoology.com/system/files/imagecache/profile_big/pictures/picture-c0b09cdead19788fb0f8be0d53b5c572_68c34cd700b90.jpg'
        };

        // --- State Management ---
        let state = {
            isPlaying: false,
            gpa: 4.0,
            score: 0,
            frame: 0
        };

        // --- Three.js Globals ---
        let scene, camera, renderer;
        let player;
        let enemies = [];
        let collectibles = [];
        let particles = [];
        let gridHelper;

        // Input Handling
        const keys = { w: false, a: false, s: false, d: false };

        // --- Initialization ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x202030);
            scene.fog = new THREE.Fog(0x202030, 20, 100);

            // Camera (Isometric-ish)
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 60, 60);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Floor (Classroom Tiles)
            const floorGeo = new THREE.PlaneGeometry(CONFIG.arenaSize * 2, CONFIG.arenaSize * 2);
            const floorMat = new THREE.MeshPhongMaterial({ color: 0x555555, side: THREE.DoubleSide });
            
            // Add grid texture to floor
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#444';
            ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#555';
            ctx.fillRect(4,4,120,120); // Tile look
            const tileTexture = new THREE.CanvasTexture(canvas);
            tileTexture.wrapS = THREE.RepeatWrapping;
            tileTexture.wrapT = THREE.RepeatWrapping;
            tileTexture.repeat.set(20, 20);
            floorMat.map = tileTexture;

            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Walls (School boundaries)
            const wallHeight = 10;
            const wallGeo = new THREE.BoxGeometry(CONFIG.arenaSize * 2, wallHeight, 2);
            const wallMat = new THREE.MeshPhongMaterial({ color: 0x334455 });
            
            // North Wall
            const wallN = new THREE.Mesh(wallGeo, wallMat);
            wallN.position.set(0, wallHeight/2, -CONFIG.arenaSize);
            scene.add(wallN);
            // South Wall
            const wallS = new THREE.Mesh(wallGeo, wallMat);
            wallS.position.set(0, wallHeight/2, CONFIG.arenaSize);
            scene.add(wallS);
            // East Wall
            const wallE = new THREE.Mesh(new THREE.BoxGeometry(2, wallHeight, CONFIG.arenaSize * 2), wallMat);
            wallE.position.set(CONFIG.arenaSize, wallHeight/2, 0);
            scene.add(wallE);
            // West Wall
            const wallW = new THREE.Mesh(new THREE.BoxGeometry(2, wallHeight, CONFIG.arenaSize * 2), wallMat);
            wallW.position.set(-CONFIG.arenaSize, wallHeight/2, 0);
            scene.add(wallW);

            // Create Player
            createPlayer();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', (e) => handleKey(e, true));
            window.addEventListener('keyup', (e) => handleKey(e, false));

            // Start Loop
            animate();
        }

        function createPlayer() {
            const geometry = new THREE.BoxGeometry(4, 4, 4);
            
            // Load Saharsh Texture
            const loader = new THREE.TextureLoader();
            loader.crossOrigin = "Anonymous";
            
            // If texture fails, fallback to orange
            let material = new THREE.MeshLambertMaterial({ color: 0xffaa00 });

            try {
                const texture = loader.load(CONFIG.saharshImage, 
                    undefined, 
                    undefined, 
                    (err) => { console.warn("Texture load failed, using color fallback"); }
                );
                material = new THREE.MeshLambertMaterial({ map: texture });
            } catch (e) {
                console.warn("Texture load error");
            }

            player = new THREE.Mesh(geometry, material);
            player.position.set(0, 2, 0);
            player.castShadow = true;
            scene.add(player);
        }

        function createEnemy() {
            // Enemy is a red book/cube
            const size = 3 + Math.random() * 2;
            const geometry = new THREE.BoxGeometry(size, size/4, size); // Book shape
            const material = new THREE.MeshLambertMaterial({ color: 0xff2222 });
            const enemy = new THREE.Mesh(geometry, material);

            // Random spawn position on edges
            const side = Math.floor(Math.random() * 4);
            const offset = CONFIG.arenaSize - 5;
            let x, z;
            
            if (side === 0) { x = -offset; z = (Math.random() * offset * 2) - offset; } // Left
            else if (side === 1) { x = offset; z = (Math.random() * offset * 2) - offset; } // Right
            else if (side === 2) { z = -offset; x = (Math.random() * offset * 2) - offset; } // Top
            else { z = offset; x = (Math.random() * offset * 2) - offset; } // Bottom

            enemy.position.set(x, 2, z);
            
            // Store direction vector towards player at spawn time (dumb tracking)
            // Or make them homing. Let's make them homing but slow.
            enemy.castShadow = true;
            
            // Add a visual "F" label if possible, or just make it red.
            // Simple mesh combination for "F"
            // Vertical bar
            const f1 = new THREE.Mesh(new THREE.BoxGeometry(1, 3, 1), new THREE.MeshBasicMaterial({color:0xffffff}));
            f1.position.y = 2;
            enemy.add(f1);
            // Top bar
            const f2 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 0.8), new THREE.MeshBasicMaterial({color:0xffffff}));
            f2.position.set(0.5, 3.2, 0);
            enemy.add(f2);
            // Mid bar
            const f3 = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.8, 0.8), new THREE.MeshBasicMaterial({color:0xffffff}));
            f3.position.set(0.5, 2.2, 0);
            enemy.add(f3);

            // Meta data
            enemy.velocity = new THREE.Vector3(0,0,0);
            
            scene.add(enemy);
            enemies.push(enemy);
        }

        function createCollectible() {
            const geometry = new THREE.BoxGeometry(3, 2, 0.5); // Laptop screen shape
            const material = new THREE.MeshPhongMaterial({ color: 0x00d2ff, emissive: 0x004466 });
            const item = new THREE.Mesh(geometry, material);

            // Base
            const baseGeo = new THREE.BoxGeometry(3, 0.2, 2.5);
            const base = new THREE.Mesh(baseGeo, new THREE.MeshPhongMaterial({ color: 0x333333 }));
            base.position.set(0, -1, 1);
            base.rotation.x = 0.2;
            item.add(base);

            const x = (Math.random() * CONFIG.arenaSize * 1.6) - (CONFIG.arenaSize * 0.8);
            const z = (Math.random() * CONFIG.arenaSize * 1.6) - (CONFIG.arenaSize * 0.8);

            item.position.set(x, 3, z);
            item.castShadow = true;
            
            // Bobbing animation data
            item.userData = {
                baseY: 3,
                offset: Math.random() * Math.PI
            };

            scene.add(item);
            collectibles.push(item);
        }

        // --- Particle System ---
        function createParticles(x, y, z, color, count) {
            const geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            
            for(let i=0; i<count; i++) {
                const p = new THREE.Mesh(geo, mat);
                p.position.set(x, y, z);
                p.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 1,
                    Math.random() * 1,
                    (Math.random() - 0.5) * 1
                );
                p.life = 1.0;
                scene.add(p);
                particles.push(p);
            }
        }

        // --- Game Logic ---

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('win-screen').classList.add('hidden');
            document.getElementById('hud').style.display = 'block';
            document.getElementById('hud-right').style.display = 'block';
            
            // Reset Stats
            state.gpa = CONFIG.gpaMax;
            state.score = 0;
            state.frame = 0;
            state.isPlaying = true;
            
            updateHUD();

            // Reset Entities
            enemies.forEach(e => scene.remove(e));
            collectibles.forEach(c => scene.remove(c));
            particles.forEach(p => scene.remove(p));
            enemies = [];
            collectibles = [];
            particles = [];

            // Reset Player
            player.position.set(0, 2, 0);
        }

        function resetGame() {
            startGame();
        }

        function gameOver(won) {
            state.isPlaying = false;
            document.getElementById('hud').style.display = 'none';
            document.getElementById('hud-right').style.display = 'none';

            if(won) {
                document.getElementById('win-screen').classList.remove('hidden');
            } else {
                document.getElementById('final-score').innerText = state.score;
                document.getElementById('game-over-screen').classList.remove('hidden');
            }
        }

        function updateHUD() {
            const bar = document.getElementById('gpa-bar');
            const val = document.getElementById('gpa-val');
            const score = document.getElementById('score-val');

            const pct = (state.gpa / CONFIG.gpaMax) * 100;
            bar.style.width = `${pct}%`;
            val.innerText = state.gpa.toFixed(2);
            score.innerText = state.score;

            // Color change based on GPA
            if(state.gpa < 1.0) val.style.color = 'red';
            else if (state.gpa < 2.5) val.style.color = 'orange';
            else val.style.color = 'white';
        }

        function createFloatingText(text, x, y) {
            const div = document.createElement('div');
            div.className = 'floating-text';
            div.innerText = text;
            // Convert 3D position to 2D screen coords
            const vec = new THREE.Vector3(x, y, 0);
            vec.project(camera);
            const sx = (vec.x * .5 + .5) * window.innerWidth;
            const sy = (-(vec.y * .5) + .5) * window.innerHeight;

            div.style.left = `${sx}px`;
            div.style.top = `${sy}px`;
            
            if(text.includes("-")) div.style.color = "#ff4b4b";
            else div.style.color = "#3cff55";

            document.body.appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }

        function update() {
            if (!state.isPlaying || !player) return;

            state.frame++;

            // 1. Player Movement
            const speed = CONFIG.playerSpeed;
            const moveVec = new THREE.Vector3(0, 0, 0);

            if (keys.w || keys.ArrowUp) moveVec.z -= speed;
            if (keys.s || keys.ArrowDown) moveVec.z += speed;
            if (keys.a || keys.ArrowLeft) moveVec.x -= speed;
            if (keys.d || keys.ArrowRight) moveVec.x += speed;

            player.position.add(moveVec);

            // Boundaries
            const limit = CONFIG.arenaSize - 2;
            player.position.x = Math.max(-limit, Math.min(limit, player.position.x));
            player.position.z = Math.max(-limit, Math.min(limit, player.position.z));

            // Rotate player slightly towards movement
            if (moveVec.length() > 0) {
                player.rotation.y += 0.1; 
                player.rotation.z = Math.sin(state.frame * 0.2) * 0.1; // Waddle
            }

            // Camera Follow (Smooth)
            camera.position.x += (player.position.x - camera.position.x) * 0.05;
            camera.position.z += (player.position.z + 40 - camera.position.z) * 0.05;
            camera.lookAt(player.position);

            // 2. Spawning
            if (state.frame % CONFIG.enemySpawnRate === 0) {
                createEnemy();
                // Increase difficulty
                if (state.frame % 600 === 0 && CONFIG.enemySpawnRate > 20) {
                    CONFIG.enemySpawnRate -= 5;
                }
            }
            if (state.frame % CONFIG.collectibleSpawnRate === 0) {
                createCollectible();
            }

            // 3. Enemy Logic
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const dir = new THREE.Vector3().subVectors(player.position, e.position).normalize();
                
                // Move towards player
                e.position.add(dir.multiplyScalar(CONFIG.enemySpeed));
                e.rotation.y += 0.05; // Spin
                e.rotation.x = Math.sin(state.frame * 0.1) * 0.2;

                // Collision with Player
                const dist = e.position.distanceTo(player.position);
                if (dist < 4) {
                    // Hit!
                    state.gpa -= CONFIG.damage;
                    createParticles(player.position.x, player.position.y, player.position.z, 0xff0000, 10);
                    createFloatingText("-0.5 GPA", player.position.x, player.position.y + 5, player.position.z);
                    
                    // Remove enemy
                    scene.remove(e);
                    enemies.splice(i, 1);
                    updateHUD();

                    if (state.gpa <= 0.05) {
                        state.gpa = 0;
                        gameOver(false);
                    }
                }
            }

            // 4. Collectible Logic
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const c = collectibles[i];
                // Bobbing
                c.position.y = c.userData.baseY + Math.sin(state.frame * 0.05 + c.userData.offset);
                c.rotation.y += 0.02;

                const dist = c.position.distanceTo(player.position);
                if (dist < 4) {
                    // Collect!
                    state.score += 100;
                    createParticles(c.position.x, c.position.y, c.position.z, 0x00d2ff, 8);
                    createFloatingText("+100 XP", c.position.x, c.position.y + 5, c.position.z);
                    
                    scene.remove(c);
                    collectibles.splice(i, 1);
                    updateHUD();

                    if(state.score >= CONFIG.scoreWin) {
                        gameOver(true);
                    }
                }
            }

            // 5. Particle Logic
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.velocity);
                p.velocity.y -= 0.05; // Gravity
                p.life -= 0.02;
                p.scale.setScalar(p.life);
                if(p.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        // --- Utility ---
        function handleKey(e, isDown) {
            if(e.key === 'w' || e.key === 'ArrowUp') keys.w = isDown;
            if(e.key === 'a' || e.key === 'ArrowLeft') keys.a = isDown;
            if(e.key === 's' || e.key === 'ArrowDown') keys.s = isDown;
            if(e.key === 'd' || e.key === 'ArrowRight') keys.d = isDown;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

        // Initialize
        init();

    </script>
</body>
</html>
